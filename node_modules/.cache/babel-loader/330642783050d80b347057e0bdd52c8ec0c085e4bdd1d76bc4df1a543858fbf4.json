{"ast":null,"code":"// Original code from : https://gist.github.com/mikelehen/3596a30bd69384624c11\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters that will sort properly).\n * 4. They're monotonically increasing.  Even if you generate more than one in the same timestamp, the\n *    latter ones will sort after the former ones.  We do this by using the previous random bits\n *    but \"incrementing\" them by 1 (only in the case of a timestamp collision).\n */\n\n// Modeled after base64 web-safe chars, but ordered by ASCII.\nvar PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n// Timestamp of last push, used to prevent local collisions if you push twice in one ms.\nvar lastPushTime = 0;\n\n// We generate 72-bits of randomness which get turned into 12 characters and appended to the\n// timestamp to prevent collisions with other clients.  We store the last characters we\n// generated because in the event of a collision, we'll use those same characters except\n// \"incremented\" by one.\nvar lastRandChars = [];\nmodule.exports = function pushid() {\n  var now = new Date().getTime();\n  var duplicateTime = now === lastPushTime;\n  lastPushTime = now;\n  var timeStampChars = new Array(8);\n  for (var i = 7; i >= 0; i--) {\n    timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n    // NOTE: Can't use << here because javascript will convert to int and lose the upper bits.\n    now = Math.floor(now / 64);\n  }\n  if (now !== 0) {\n    throw new Error('We should have converted the entire timestamp.');\n  }\n  var id = timeStampChars.join('');\n  if (duplicateTime) {\n    // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.\n    for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n      lastRandChars[i] = 0;\n    }\n    lastRandChars[i]++;\n  } else {\n    for (i = 0; i < 12; i++) {\n      lastRandChars[i] = Math.floor(Math.random() * 64);\n    }\n  }\n  for (i = 0; i < 12; i++) {\n    id += PUSH_CHARS.charAt(lastRandChars[i]);\n  }\n  if (id.length != 20) {\n    throw new Error('Length should be 20.');\n  }\n  return id;\n};","map":{"version":3,"names":["PUSH_CHARS","lastPushTime","lastRandChars","module","exports","pushid","now","Date","getTime","duplicateTime","timeStampChars","Array","i","charAt","Math","floor","Error","id","join","random","length"],"sources":["/Users/yashwanth/Downloads/Codify/Codify/client/node_modules/pushid/index.js"],"sourcesContent":["// Original code from : https://gist.github.com/mikelehen/3596a30bd69384624c11\n\n/**\n * Fancy ID generator that creates 20-character string identifiers with the following properties:\n *\n * 1. They're based on timestamp so that they sort *after* any existing ids.\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't collide with other clients' IDs.\n * 3. They sort *lexicographically* (so the timestamp is converted to characters that will sort properly).\n * 4. They're monotonically increasing.  Even if you generate more than one in the same timestamp, the\n *    latter ones will sort after the former ones.  We do this by using the previous random bits\n *    but \"incrementing\" them by 1 (only in the case of a timestamp collision).\n */\n\n// Modeled after base64 web-safe chars, but ordered by ASCII.\nvar PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\n\n// Timestamp of last push, used to prevent local collisions if you push twice in one ms.\nvar lastPushTime = 0;\n\n// We generate 72-bits of randomness which get turned into 12 characters and appended to the\n// timestamp to prevent collisions with other clients.  We store the last characters we\n// generated because in the event of a collision, we'll use those same characters except\n// \"incremented\" by one.\nvar lastRandChars = [];\n\nmodule.exports = function pushid() {\n  var now = new Date().getTime();\n  var duplicateTime = (now === lastPushTime);\n  lastPushTime = now;\n\n  var timeStampChars = new Array(8);\n  for (var i = 7; i >= 0; i--) {\n    timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n    // NOTE: Can't use << here because javascript will convert to int and lose the upper bits.\n    now = Math.floor(now / 64);\n  }\n\n  if (now !== 0) {\n    throw new Error('We should have converted the entire timestamp.');\n  }\n\n  var id = timeStampChars.join('');\n\n  if ( duplicateTime ) {\n    // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.\n    for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n      lastRandChars[i] = 0;\n    }\n    lastRandChars[i]++;\n  }\n  else {\n    for (i = 0; i < 12; i++) {\n      lastRandChars[i] = Math.floor(Math.random() * 64);\n    }\n  }\n\n  for (i = 0; i < 12; i++) {\n    id += PUSH_CHARS.charAt(lastRandChars[i]);\n  }\n\n  if ( id.length != 20 ) {\n    throw new Error('Length should be 20.');\n  }\n\n  return id;\n};\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAIA,UAAU,GAAG,kEAAkE;;AAEnF;AACA,IAAIC,YAAY,GAAG,CAAC;;AAEpB;AACA;AACA;AACA;AACA,IAAIC,aAAa,GAAG,EAAE;AAEtBC,MAAM,CAACC,OAAO,GAAG,SAASC,MAAMA,CAAA,EAAG;EACjC,IAAIC,GAAG,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;EAC9B,IAAIC,aAAa,GAAIH,GAAG,KAAKL,YAAa;EAC1CA,YAAY,GAAGK,GAAG;EAElB,IAAII,cAAc,GAAG,IAAIC,KAAK,CAAC,CAAC,CAAC;EACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC3BF,cAAc,CAACE,CAAC,CAAC,GAAGZ,UAAU,CAACa,MAAM,CAACP,GAAG,GAAG,EAAE,CAAC;IAC/C;IACAA,GAAG,GAAGQ,IAAI,CAACC,KAAK,CAACT,GAAG,GAAG,EAAE,CAAC;EAC5B;EAEA,IAAIA,GAAG,KAAK,CAAC,EAAE;IACb,MAAM,IAAIU,KAAK,CAAC,gDAAgD,CAAC;EACnE;EAEA,IAAIC,EAAE,GAAGP,cAAc,CAACQ,IAAI,CAAC,EAAE,CAAC;EAEhC,IAAKT,aAAa,EAAG;IACnB;IACA,KAAKG,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,IAAIV,aAAa,CAACU,CAAC,CAAC,KAAK,EAAE,EAAEA,CAAC,EAAE,EAAE;MACnDV,aAAa,CAACU,CAAC,CAAC,GAAG,CAAC;IACtB;IACAV,aAAa,CAACU,CAAC,CAAC,EAAE;EACpB,CAAC,MACI;IACH,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MACvBV,aAAa,CAACU,CAAC,CAAC,GAAGE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACK,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC;IACnD;EACF;EAEA,KAAKP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IACvBK,EAAE,IAAIjB,UAAU,CAACa,MAAM,CAACX,aAAa,CAACU,CAAC,CAAC,CAAC;EAC3C;EAEA,IAAKK,EAAE,CAACG,MAAM,IAAI,EAAE,EAAG;IACrB,MAAM,IAAIJ,KAAK,CAAC,sBAAsB,CAAC;EACzC;EAEA,OAAOC,EAAE;AACX,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}